<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>2XKO Overlay</title>
<style>
  html, body {
    width: 100%;
    height: 100%;
    margin: 0;
    background: transparent;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  #app {
    transform: scale(1);
  }
  canvas {
    width: 1000px;
    height: 800px;
    background: transparent;
  }
  .controls {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
  }
  .buttons {
    display: grid;
    grid-template-columns: repeat(4, 60px);
    grid-gap: 8px;
  }
  .btn {
    width: 60px;
    height: 60px;
    border-radius: 12px;
    background: rgba(0,0,0,0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    text-transform: uppercase;
    transition: 0.1s;
  }
  .btn.active {
    background: rgba(128,128,128,1.0);
    box-shadow: 0 0 10px rgba(0,0,0,0.8);
    transform: scale(1.05);
  }
  .toggle {
    font-size: 14px;
    cursor: pointer;
    user-select: none;
  }
</style>
</head>
<body>
<div id="app">
  <canvas id="stick"></canvas>
  <div class="controls">
    <label class="toggle"><input type="checkbox" id="toggleBtns" checked> Show Buttons</label>
    <div class="buttons" id="buttonGrid">
      <div class="btn l">L</div>
      <div class="btn m">M</div>
      <div class="btn h">H</div>
      <div class="btn tag">Tag</div>
      <div class="btn parry">Parry</div>
      <div class="btn dash">Dash</div>
      <div class="btn s1">S1</div>
      <div class="btn s2">S2</div>
      <div class="btn l3">L3</div>
      <div class="btn r3">R3</div>
      <div class="btn select">Select</div>
      <div class="btn start">Start</div>
    </div>
  </div>
</div>

<script>
  const cfg = {
    deadzone: 0.14,
    trail: 24,
    stickSource: 'both', // left stick + dpad
    invertY: false,
    map: {
      L: 0,   // X
      M: 3,   // Y
      H: 1,   // B
      Tag: 2, // A
      Parry: 4, // LB
      Dash: 5,  // RB
      S1: 6,    // LT
      S2: 7,    // RT
      L3: 10,   // LS click
      R3: 11,   // RS click
      Select: 8, // Back/View
      Start: 9   // Menu/Options
    }
  };

  let gamepadIndex = null;
  window.addEventListener('gamepadconnected', e => { gamepadIndex = e.gamepad.index; });
  window.addEventListener('gamepaddisconnected', () => { gamepadIndex = null; });

  function getPad() {
    const pads = navigator.getGamepads ? navigator.getGamepads() : [];
    return pads && pads[gamepadIndex ?? 0];
  }

  const btnEls = {
    L: document.querySelector('.btn.l'),
    M: document.querySelector('.btn.m'),
    H: document.querySelector('.btn.h'),
    Tag: document.querySelector('.btn.tag'),
    Parry: document.querySelector('.btn.parry'),
    Dash: document.querySelector('.btn.dash'),
    S1: document.querySelector('.btn.s1'),
    S2: document.querySelector('.btn.s2'),
    L3: document.querySelector('.btn.l3'),
    R3: document.querySelector('.btn.r3'),
    Select: document.querySelector('.btn.select'),
    Start: document.querySelector('.btn.start')
  };

  function updateButtons(pad) {
    if (!pad || !pad.buttons) return;
    for (const key of Object.keys(btnEls)) {
      const idx = cfg.map[key];
      const pressed = !!(pad.buttons?.[idx]?.pressed);
      if (btnEls[key]) btnEls[key].classList.toggle('active', pressed);
    }
  }

  // Toggle button visibility
  document.getElementById('toggleBtns').addEventListener('change', e => {
    document.getElementById('buttonGrid').style.display = e.target.checked ? 'grid' : 'none';
  });

  const canvas = document.getElementById('stick');
  const ctx = canvas.getContext('2d');
  const DPR = window.devicePixelRatio || 1;
  function resizeCanvas() {
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width * DPR;
    canvas.height = rect.height * DPR;
  }
  resizeCanvas();
  addEventListener('resize', resizeCanvas);

  const trail = [];

  function radialDeadzone(x, y, dz) {
    const mag = Math.hypot(x, y);
    if (mag < dz) return {x: 0, y: 0};
    const s = (mag - dz) / (1 - dz);
    const n = s / (mag || 1);
    return { x: x * n, y: y * n };
  }

  function getStickXY(pad) {
    if (!pad) return {x:0, y:0};
    let x = 0, y = 0;
    const ls = radialDeadzone(pad.axes?.[0] || 0, pad.axes?.[1] || 0, cfg.deadzone);
    x += ls.x; y += ls.y;
    const up = pad.buttons?.[12]?.pressed ? 1 : 0;
    const down = pad.buttons?.[13]?.pressed ? 1 : 0;
    const left = pad.buttons?.[14]?.pressed ? 1 : 0;
    const right = pad.buttons?.[15]?.pressed ? 1 : 0;
    x += (right - left);
    y += (down - up);
    if (cfg.invertY) y *= -1;
    return clampCircle(x, y);
  }

  function clampCircle(x, y) {
    const mag = Math.hypot(x, y);
    if (mag > 1) {
      x /= mag;
      y /= mag;
    }
    return {x, y};
  }

  // Smoothing
  let smooth = {x:0, y:0};
  const SMOOTHING = 0.5;

  function getSmoothedXY(pad) {
    const target = getStickXY(pad);
    smooth.x += (target.x - smooth.x) * SMOOTHING;
    smooth.y += (target.y - smooth.y) * SMOOTHING;
    return clampCircle(smooth.x, smooth.y);
  }

  // Direction markers (8-way)
  const directions = [
    {x: 0, y: -1},
    {x: 1, y: -1},
    {x: 1, y: 0},
    {x: 1, y: 1},
    {x: 0, y: 1},
    {x: -1, y: 1},
    {x: -1, y: 0},
    {x: -1, y: -1},
  ];

  function getClosestDirection(x, y) {
    const mag = Math.hypot(x, y);
    if (mag < 0.25) return -1; // ðŸ”¹ threshold for "no input"
  
    let best = -1, bestDot = -Infinity;
    for (let i = 0; i < directions.length; i++) {
      const d = directions[i];
      const dot = (x * d.x + y * d.y) / mag / Math.hypot(d.x, d.y);
      if (dot > bestDot) {
        bestDot = dot;
        best = i;
      }
    }
    return best;
  }

  function drawStick() {
    const w = canvas.width, h = canvas.height;
    const pad = getPad();
    const {x, y} = getSmoothedXY(pad);

    trail.push({ x, y });
    while (trail.length > cfg.trail) trail.shift();

    ctx.clearRect(0, 0, w, h);

    const r = Math.min(w, h) / 2 - 10;
    const cx = w / 2, cy = h / 2;
    const radius = 8 * DPR;

    ctx.save();
    ctx.translate(cx, cy);

    // gate
    ctx.strokeStyle = 'rgba(255,255,255,1.0)';
    ctx.lineWidth = 6 * DPR;
    ctx.beginPath();
    ctx.arc(0, 0, r, 0, Math.PI * 2);
    ctx.stroke();

    // direction markers
    const activeDir = getClosestDirection(x, y);
    const markerRadius = 10 * DPR;
    directions.forEach((d, i) => {
      const norm = Math.hypot(d.x, d.y);
      const mx = (d.x / norm) * r;
      const my = (d.y / norm) * r;
      ctx.beginPath();
      ctx.arc(mx, my, markerRadius, 0, Math.PI * 2);
      ctx.fillStyle = (i === activeDir) ? 'rgba(120,170,255,0.95)' : 'rgba(255,255,255,0.2)';
      ctx.fill();
    });

    // trail
    if (trail.length > 1) {
      for (let i = 1; i < trail.length; i++) {
        const p0 = trail[i - 1], p1 = trail[i];
        const t = i / trail.length;
        ctx.beginPath();
        ctx.moveTo(p0.x * r, p0.y * r);
        ctx.lineTo(p1.x * r, p1.y * r);
        ctx.lineWidth = (8 * DPR) * t;
        ctx.lineCap = "round";
        ctx.strokeStyle = 'rgba(120,170,255,0.9)';
        ctx.stroke();
      }
    }

    // stick dot
    ctx.beginPath();
    ctx.fillStyle = 'rgba(120,170,255,0.95)';
    ctx.arc(x * r, y * r, radius, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();

    updateButtons(pad);
    requestAnimationFrame(drawStick);
  }

  requestAnimationFrame(drawStick);
</script>
</body>
</html>
