<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>2XKO Overlay (Xbox Layout)</title>
<style>
  html, body {
    width: 100%;
    height: 100%;
    margin: 0;
    background: transparent;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  #app {
    transform: scale(1);
  }
  canvas {
    width: 1000px;
    height: 800px;
    background: transparent;
  }
  .controls {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
  }

  /* Button Grid Layout */
  .buttons {
    display: grid;
    grid-template-areas:
      "lb rb lt rt view menu"
      ".  y  .  .   .   ."
      "x  .  b  .   .   ."
      ".  a  .  .   .   ."
      "ls .  rs .  .   .";
    grid-template-columns: repeat(6, 60px);
    grid-template-rows: repeat(5, 60px);
    gap: 8px;
    justify-content: center;
  }

  .btn {
    width: 60px;
    height: 60px;
    border-radius: 12px;
    background: rgba(0,0,0,0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    text-transform: uppercase;
    transition: 0.1s;
  }
  .btn.active {
    background: rgba(128,128,128,1.0);
    box-shadow: 0 0 10px rgba(0,0,0,0.8);
    transform: scale(1.05);
  }
  .toggle {
    font-size: 14px;
    cursor: pointer;
    user-select: none;
  }

  /* Assign grid areas */
  .lb   { grid-area: lb; }
  .rb   { grid-area: rb; }
  .lt   { grid-area: lt; }
  .rt   { grid-area: rt; }
  .view { grid-area: view; }
  .menu { grid-area: menu; }
  .x    { grid-area: x; }
  .y    { grid-area: y; }
  .a    { grid-area: a; }
  .b    { grid-area: b; }
  .ls   { grid-area: ls; }
  .rs   { grid-area: rs; }
</style>
</head>
<body>
<div id="app">
  <canvas id="stick"></canvas>
  <div class="controls">
    <label class="toggle"><input type="checkbox" id="toggleBtns" checked> Show Buttons</label>
    <div class="buttons" id="buttonGrid">
      <div class="btn lb">LB</div>
      <div class="btn rb">RB</div>
      <div class="btn lt">LT</div>
      <div class="btn rt">RT</div>
      <div class="btn view">View</div>
      <div class="btn menu">Menu</div>
      <div class="btn x">X</div>
      <div class="btn y">Y</div>
      <div class="btn a">A</div>
      <div class="btn b">B</div>
      <div class="btn ls">LS</div>
      <div class="btn rs">RS</div>
    </div>
  </div>
</div>

<script>
  const cfg = {
    deadzone: 0.14,
    trail: 24,
    stickSource: 'both',
    invertY: false,
    map: {
      X: 0,   // X
      Y: 3,   // Y
      B: 1,   // B
      A: 2,   // A
      LB: 4,  // LB
      RB: 5,  // RB
      LT: 6,  // LT
      RT: 7,  // RT
      LS: 10, // LS click
      RS: 11, // RS click
      View: 8, // Back/View
      Menu: 9  // Menu/Options
    }
  };

  let gamepadIndex = null;
  window.addEventListener('gamepadconnected', e => { gamepadIndex = e.gamepad.index; });
  window.addEventListener('gamepaddisconnected', () => { gamepadIndex = null; });

  function getPad() {
    const pads = navigator.getGamepads ? navigator.getGamepads() : [];
    return pads && pads[gamepadIndex ?? 0];
  }

  const btnEls = {
    X: document.querySelector('.btn.x'),
    Y: document.querySelector('.btn.y'),
    B: document.querySelector('.btn.b'),
    A: document.querySelector('.btn.a'),
    LB: document.querySelector('.btn.lb'),
    RB: document.querySelector('.btn.rb'),
    LT: document.querySelector('.btn.lt'),
    RT: document.querySelector('.btn.rt'),
    LS: document.querySelector('.btn.ls'),
    RS: document.querySelector('.btn.rs'),
    View: document.querySelector('.btn.view'),
    Menu: document.querySelector('.btn.menu')
  };

  function updateButtons(pad) {
    if (!pad || !pad.buttons) return;
    for (const key of Object.keys(btnEls)) {
      const idx = cfg.map[key];
      const pressed = !!(pad.buttons?.[idx]?.pressed);
      if (btnEls[key]) btnEls[key].classList.toggle('active', pressed);
    }
  }

  document.getElementById('toggleBtns').addEventListener('change', e => {
    document.getElementById('buttonGrid').style.display = e.target.checked ? 'grid' : 'none';
  });

  const canvas = document.getElementById('stick');
  const ctx = canvas.getContext('2d');
  const DPR = window.devicePixelRatio || 1;
  function resizeCanvas() {
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width * DPR;
    canvas.height = rect.height * DPR;
  }
  resizeCanvas();
  addEventListener('resize', resizeCanvas);

  const trail = [];

  function radialDeadzone(x, y, dz) {
    const mag = Math.hypot(x, y);
    if (mag < dz) return {x: 0, y: 0};
    const s = (mag - dz) / (1 - dz);
    const n = s / (mag || 1);
    return { x: x * n, y: y * n };
  }

  function getStickXY(pad) {
    if (!pad) return {x:0, y:0};
    let x = 0, y = 0;
    const ls = radialDeadzone(pad.axes?.[0] || 0, pad.axes?.[1] || 0, cfg.deadzone);
    x += ls.x; y += ls.y;
    const up = pad.buttons?.[12]?.pressed ? 1 : 0;
    const down = pad.buttons?.[13]?.pressed ? 1 : 0;
    const left = pad.buttons?.[14]?.pressed ? 1 : 0;
    const right = pad.buttons?.[15]?.pressed ? 1 : 0;
    x += (right - left);
    y += (down - up);
    if (cfg.invertY) y *= -1;
    return clampCircle(x, y);
  }

  function clampCircle(x, y) {
    const mag = Math.hypot(x, y);
    if (mag > 1) {
      x /= mag;
      y /= mag;
    }
    return {x, y};
  }

  let smooth = {x:0, y:0};
  const SMOOTHING = 0.5;

  function getSmoothedXY(pad) {
    const target = getStickXY(pad);
    smooth.x += (target.x - smooth.x) * SMOOTHING;
    smooth.y += (target.y - smooth.y) * SMOOTHING;
    return clampCircle(smooth.x, smooth.y);
  }

  const directions = [
    {x: 0, y: -1},
    {x: 1, y: -1},
    {x: 1, y: 0},
    {x: 1, y: 1},
    {x: 0, y: 1},
    {x: -1, y: 1},
    {x: -1, y: 0},
    {x: -1, y: -1},
  ];

  function getClosestDirection(x, y) {
    const mag = Math.hypot(x, y);
    if (mag < 0.25) return -1;
    let best = -1, bestDot = -Infinity;
    for (let i = 0; i < directions.length; i++) {
      const d = directions[i];
      const dot = (x * d.x + y * d.y) / mag / Math.hypot(d.x, d.y);
      if (dot > bestDot) {
        bestDot = dot;
        best = i;
      }
    }
    return best;
  }

  function drawStick() {
    const w = canvas.width, h = canvas.height;
    const pad = getPad();
    const {x, y} = getSmoothedXY(pad);

    trail.push({ x, y });
    while (trail.length > cfg.trail) trail.shift();

    ctx.clearRect(0, 0, w, h);

    const r = Math.min(w, h) / 2 - 10;
    const cx = w / 2, cy = h / 2;
    const radius = 8 * DPR;

    ctx.save();
    ctx.translate(cx, cy);

    ctx.strokeStyle = 'rgba(255,255,255,1.0)';
    ctx.lineWidth = 6 * DPR;
    ctx.beginPath();
    ctx.arc(0, 0, r, 0, Math.PI * 2);
    ctx.stroke();

    const activeDir = getClosestDirection(x, y);
    const markerRadius = 10 * DPR;
    directions.forEach((d, i) => {
      const norm = Math.hypot(d.x, d.y);
      const mx = (d.x / norm) * r;
      const my = (d.y / norm) * r;
      ctx.beginPath();
      ctx.arc(mx, my, markerRadius, 0, Math.PI * 2);
      ctx.fillStyle = (i === activeDir) ? 'rgba(120,170,255,0.95)' : 'rgba(255,255,255,0.2)';
      ctx.fill();
    });

    if (trail.length > 1) {
      for (let i = 1; i < trail.length; i++) {
        const p0 = trail[i - 1], p1 = trail[i];
        const t = i / trail.length;
        ctx.beginPath();
        ctx.moveTo(p0.x * r, p0.y * r);
        ctx.lineTo(p1.x * r, p1.y * r);
        ctx.lineWidth = (8 * DPR) * t;
        ctx.lineCap = "round";
        ctx.strokeStyle = 'rgba(120,170,255,0.9)';
        ctx.stroke();
      }
    }

    ctx.beginPath();
    ctx.fillStyle = 'rgba(120,170,255,0.95)';
    ctx.arc(x * r, y * r, radius, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();

    updateButtons(pad);
    requestAnimationFrame(drawStick);
  }

  requestAnimationFrame(drawStick);
</script>
</body>
</html>
